<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>utils.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
  </script>

  <script src="static/js/doc.js">
  </script>

  <meta charset="utf8">
</head>

<body onload="prettyPrint()">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="closure_goog_uri_utils.js.html">utils.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line2"></a>// you may not use this file except in compliance with the License.
<a name="line3"></a>// You may obtain a copy of the License at
<a name="line4"></a>//
<a name="line5"></a>//     http://www.apache.org/licenses/LICENSE-2.0
<a name="line6"></a>//
<a name="line7"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line8"></a>// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<a name="line9"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line10"></a>// See the License for the specific language governing permissions and
<a name="line11"></a>// limitations under the License.
<a name="line12"></a>
<a name="line13"></a>// Copyright 2008 Google Inc. All rights reserved.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Simple utilities for dealing with URI strings.
<a name="line17"></a> *
<a name="line18"></a> * This is intended to be a lightweight alternative to constructing goog.Uri
<a name="line19"></a> * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
<a name="line20"></a> * of how much of its functionality you use, this is designed to be a set of
<a name="line21"></a> * mostly-independent utilities so that the compiler includes only what is
<a name="line22"></a> * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
<a name="line23"></a> * 1.5k post-gzip.  To ensure the savings remain, future developers should
<a name="line24"></a> * avoid adding new functionality to existing functions, but instead create
<a name="line25"></a> * new ones and factor out shared code.
<a name="line26"></a> *
<a name="line27"></a> * Many of these utilities have limited functionality, tailored to common
<a name="line28"></a> * cases.  The query parameter utilities assume that the parameter keys are
<a name="line29"></a> * already encoded, since most keys are compile-time alphanumeric strings.  The
<a name="line30"></a> * query parameter mutation utilities also do not tolerate fragment identifiers.
<a name="line31"></a> *
<a name="line32"></a> * By design, these functions can be slower than goog.Uri equivalents.
<a name="line33"></a> * Repeated calls to some of functions may be quadratic in behavior for IE,
<a name="line34"></a> * although the effect is somewhat limited given the 2kb limit.
<a name="line35"></a> *
<a name="line36"></a> * One advantage of the limited functionality here is that this approach is
<a name="line37"></a> * less sensitive to differences in URI encodings than goog.Uri, since these
<a name="line38"></a> * functions modify the strings in place, rather than decoding and
<a name="line39"></a> * re-encoding.
<a name="line40"></a> *
<a name="line41"></a> * Uses features of RFC 3986 for parsing/formatting URIs:
<a name="line42"></a> *   http://gbiv.com/protocols/uri/rfc/rfc3986.html
<a name="line43"></a> *
<a name="line44"></a> */
<a name="line45"></a>
<a name="line46"></a>goog.provide(&#39;goog.uri.utils&#39;);
<a name="line47"></a>goog.provide(&#39;goog.uri.utils.ComponentIndex&#39;);
<a name="line48"></a>
<a name="line49"></a>goog.require(&#39;goog.asserts&#39;);
<a name="line50"></a>goog.require(&#39;goog.string&#39;);
<a name="line51"></a>
<a name="line52"></a>
<a name="line53"></a>/**
<a name="line54"></a> * Character codes inlined to avoid object allocations due to charCode.
<a name="line55"></a> * @enum {number}
<a name="line56"></a> * @private
<a name="line57"></a> */
<a name="line58"></a>goog.uri.utils.CharCode_ = {
<a name="line59"></a>  AMPERSAND: 38,
<a name="line60"></a>  EQUAL: 61,
<a name="line61"></a>  HASH: 35,
<a name="line62"></a>  QUESTION: 63
<a name="line63"></a>};
<a name="line64"></a>
<a name="line65"></a>
<a name="line66"></a>/**
<a name="line67"></a> * Builds a URI string from already-encoded parts.
<a name="line68"></a> *
<a name="line69"></a> * No encoding is performed.  Any component may be omitted as either null or
<a name="line70"></a> * undefined.
<a name="line71"></a> *
<a name="line72"></a> * @param {?string} opt_scheme The scheme such as &#39;http&#39;.
<a name="line73"></a> * @param {?string} opt_userInfo The user name before the &#39;@&#39;.
<a name="line74"></a> * @param {?string} opt_domain The domain such as &#39;www.google.com&#39;, already
<a name="line75"></a> *     URI-encoded.
<a name="line76"></a> * @param {string|number|null} opt_port The port number.
<a name="line77"></a> * @param {?string} opt_path The path, already URI-encoded.  If it is not
<a name="line78"></a> *     empty, it must begin with a slash.
<a name="line79"></a> * @param {?string} opt_queryData The URI-encoded query data.
<a name="line80"></a> * @param {?string} opt_fragment The URI-encoded fragment identifier.
<a name="line81"></a> * @return {string} The fully combined URI.
<a name="line82"></a> */
<a name="line83"></a>goog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo,
<a name="line84"></a>    opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
<a name="line85"></a>  var out = [];
<a name="line86"></a>
<a name="line87"></a>  if (opt_scheme) {
<a name="line88"></a>    out.push(opt_scheme, &#39;:&#39;);
<a name="line89"></a>  }
<a name="line90"></a>
<a name="line91"></a>  if (opt_domain) {
<a name="line92"></a>    out.push(&#39;//&#39;);
<a name="line93"></a>
<a name="line94"></a>    if (opt_userInfo) {
<a name="line95"></a>      out.push(opt_userInfo, &#39;@&#39;);
<a name="line96"></a>    }
<a name="line97"></a>
<a name="line98"></a>    out.push(opt_domain);
<a name="line99"></a>
<a name="line100"></a>    if (opt_port) {
<a name="line101"></a>      out.push(&#39;:&#39;, opt_port);
<a name="line102"></a>    }
<a name="line103"></a>  }
<a name="line104"></a>
<a name="line105"></a>  if (opt_path) {
<a name="line106"></a>    out.push(opt_path);
<a name="line107"></a>  }
<a name="line108"></a>
<a name="line109"></a>  if (opt_queryData) {
<a name="line110"></a>    out.push(&#39;?&#39;, opt_queryData);
<a name="line111"></a>  }
<a name="line112"></a>
<a name="line113"></a>  if (opt_fragment) {
<a name="line114"></a>    out.push(&#39;#&#39;, opt_fragment);
<a name="line115"></a>  }
<a name="line116"></a>
<a name="line117"></a>  return out.join(&#39;&#39;);
<a name="line118"></a>};
<a name="line119"></a>
<a name="line120"></a>
<a name="line121"></a>/**
<a name="line122"></a> * A regular expression for breaking a URI into its component parts.
<a name="line123"></a> *
<a name="line124"></a> * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
<a name="line125"></a> * As the &quot;first-match-wins&quot; algorithm is identical to the &quot;greedy&quot;
<a name="line126"></a> * disambiguation method used by POSIX regular expressions, it is natural and
<a name="line127"></a> * commonplace to use a regular expression for parsing the potential five
<a name="line128"></a> * components of a URI reference.
<a name="line129"></a> *
<a name="line130"></a> * The following line is the regular expression for breaking-down a
<a name="line131"></a> * well-formed URI reference into its components.
<a name="line132"></a> *
<a name="line133"></a> * &lt;pre&gt;
<a name="line134"></a> * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
<a name="line135"></a> *  12            3  4          5       6  7        8 9
<a name="line136"></a> * &lt;/pre&gt;
<a name="line137"></a> *
<a name="line138"></a> * The numbers in the second line above are only to assist readability; they
<a name="line139"></a> * indicate the reference points for each subexpression (i.e., each paired
<a name="line140"></a> * parenthesis). We refer to the value matched for subexpression &lt;n&gt; as $&lt;n&gt;.
<a name="line141"></a> * For example, matching the above expression to
<a name="line142"></a> * &lt;pre&gt;
<a name="line143"></a> *     http://www.ics.uci.edu/pub/ietf/uri/#Related
<a name="line144"></a> * &lt;/pre&gt;
<a name="line145"></a> * results in the following subexpression matches:
<a name="line146"></a> * &lt;pre&gt;
<a name="line147"></a> *    $1 = http:
<a name="line148"></a> *    $2 = http
<a name="line149"></a> *    $3 = //www.ics.uci.edu
<a name="line150"></a> *    $4 = www.ics.uci.edu
<a name="line151"></a> *    $5 = /pub/ietf/uri/
<a name="line152"></a> *    $6 = &lt;undefined&gt;
<a name="line153"></a> *    $7 = &lt;undefined&gt;
<a name="line154"></a> *    $8 = #Related
<a name="line155"></a> *    $9 = Related
<a name="line156"></a> * &lt;/pre&gt;
<a name="line157"></a> * where &lt;undefined&gt; indicates that the component is not present, as is the
<a name="line158"></a> * case for the query component in the above example. Therefore, we can
<a name="line159"></a> * determine the value of the five components as
<a name="line160"></a> * &lt;pre&gt;
<a name="line161"></a> *    scheme    = $2
<a name="line162"></a> *    authority = $4
<a name="line163"></a> *    path      = $5
<a name="line164"></a> *    query     = $7
<a name="line165"></a> *    fragment  = $9
<a name="line166"></a> * &lt;/pre&gt;
<a name="line167"></a> *
<a name="line168"></a> * The regular expression has been modified slightly to expose the
<a name="line169"></a> * userInfo, domain, and port separately from the authority.
<a name="line170"></a> * The modified version yields
<a name="line171"></a> * &lt;pre&gt;
<a name="line172"></a> *    $1 = http              scheme
<a name="line173"></a> *    $2 = &lt;undefined&gt;       userInfo -\
<a name="line174"></a> *    $3 = www.ics.uci.edu   domain     | authority
<a name="line175"></a> *    $4 = &lt;undefined&gt;       port     -/
<a name="line176"></a> *    $5 = /pub/ietf/uri/    path
<a name="line177"></a> *    $6 = &lt;undefined&gt;       query without ?
<a name="line178"></a> *    $7 = Related           fragment without #
<a name="line179"></a> * &lt;/pre&gt;
<a name="line180"></a> * @type {!RegExp}
<a name="line181"></a> * @private
<a name="line182"></a> */
<a name="line183"></a>goog.uri.utils.splitRe_ = new RegExp(
<a name="line184"></a>    &#39;^&#39; +
<a name="line185"></a>    &#39;(?:&#39; +
<a name="line186"></a>      &#39;([^:/?#]+)&#39; +         // scheme
<a name="line187"></a>    &#39;:)?&#39; +
<a name="line188"></a>    &#39;(?://&#39; +
<a name="line189"></a>      &#39;(?:([^/?#]*)@)?&#39; +    // userInfo
<a name="line190"></a>      &#39;([^/?#:@]*)&#39; +        // domain
<a name="line191"></a>      &#39;(?::([0-9]+))?&#39; +     // port
<a name="line192"></a>    &#39;)?&#39; +
<a name="line193"></a>    &#39;([^?#]+)?&#39; +            // path
<a name="line194"></a>    &#39;(?:\\?([^#]*))?&#39; +      // query
<a name="line195"></a>    &#39;(?:#(.*))?&#39; +           // fragment
<a name="line196"></a>    &#39;$&#39;);
<a name="line197"></a>
<a name="line198"></a>
<a name="line199"></a>/**
<a name="line200"></a> * The index of each URI component in the return value of goog.uri.utils.split.
<a name="line201"></a> * @enum {number}
<a name="line202"></a> */
<a name="line203"></a>goog.uri.utils.ComponentIndex = {
<a name="line204"></a>  SCHEME: 1,
<a name="line205"></a>  USER_INFO: 2,
<a name="line206"></a>  DOMAIN: 3,
<a name="line207"></a>  PORT: 4,
<a name="line208"></a>  PATH: 5,
<a name="line209"></a>  QUERY_DATA: 6,
<a name="line210"></a>  FRAGMENT: 7
<a name="line211"></a>};
<a name="line212"></a>
<a name="line213"></a>
<a name="line214"></a>/**
<a name="line215"></a> * Splits a URI into its component parts.
<a name="line216"></a> *
<a name="line217"></a> * Each component can be accessed via the component indices; for example:
<a name="line218"></a> * &lt;pre&gt;
<a name="line219"></a> * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
<a name="line220"></a> * &lt;/pre&gt;
<a name="line221"></a> *
<a name="line222"></a> * @param {string} uri The URI string to examine.
<a name="line223"></a> * @return {!Array.&lt;string|undefined&gt;} Each component still URI-encoded.
<a name="line224"></a> *     Each component that is present will contain the encoded value, whereas
<a name="line225"></a> *     components that are not present will be undefined or empty, depending
<a name="line226"></a> *     on the browser&#39;s regular expression implementation.  Never null, since
<a name="line227"></a> *     arbitrary strings may still look like path names.
<a name="line228"></a> */
<a name="line229"></a>goog.uri.utils.split = function(uri) {
<a name="line230"></a>  // See @return comment -- never null.
<a name="line231"></a>  return /** @type {!Array.&lt;string|undefined&gt;} */ (
<a name="line232"></a>      uri.match(goog.uri.utils.splitRe_));
<a name="line233"></a>};
<a name="line234"></a>
<a name="line235"></a>
<a name="line236"></a>/**
<a name="line237"></a> * @param {?string} uri A possibly null string.
<a name="line238"></a> * @return {?string} The string URI-decoded, or null if uri is null.
<a name="line239"></a> * @private
<a name="line240"></a> */
<a name="line241"></a>goog.uri.utils.decodeIfPossible_ = function(uri) {
<a name="line242"></a>  return uri &amp;&amp; decodeURIComponent(uri);
<a name="line243"></a>};
<a name="line244"></a>
<a name="line245"></a>
<a name="line246"></a>/**
<a name="line247"></a> * Gets a URI component by index.
<a name="line248"></a> *
<a name="line249"></a> * It is preferred to use the getPathEncoded() variety of functions ahead,
<a name="line250"></a> * since they are more readable.
<a name="line251"></a> *
<a name="line252"></a> * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
<a name="line253"></a> * @param {string} uri The URI to examine.
<a name="line254"></a> * @return {?string} The still-encoded component, or null if the component
<a name="line255"></a> *     is not present.
<a name="line256"></a> * @private
<a name="line257"></a> */
<a name="line258"></a>goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
<a name="line259"></a>  // Convert undefined, null, and empty string into null.
<a name="line260"></a>  return goog.uri.utils.split(uri)[componentIndex] || null;
<a name="line261"></a>};
<a name="line262"></a>
<a name="line263"></a>
<a name="line264"></a>/**
<a name="line265"></a> * @param {string} uri The URI to examine.
<a name="line266"></a> * @return {?string} The protocol or scheme, or null if none.  Does not
<a name="line267"></a> *     include trailing colons or slashes.
<a name="line268"></a> */
<a name="line269"></a>goog.uri.utils.getScheme = function(uri) {
<a name="line270"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line271"></a>      goog.uri.utils.ComponentIndex.SCHEME, uri);
<a name="line272"></a>};
<a name="line273"></a>
<a name="line274"></a>
<a name="line275"></a>/**
<a name="line276"></a> * @param {string} uri The URI to examine.
<a name="line277"></a> * @return {?string} The user name still encoded, or null if none.
<a name="line278"></a> */
<a name="line279"></a>goog.uri.utils.getUserInfoEncoded = function(uri) {
<a name="line280"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line281"></a>      goog.uri.utils.ComponentIndex.USER_INFO, uri);
<a name="line282"></a>};
<a name="line283"></a>
<a name="line284"></a>
<a name="line285"></a>/**
<a name="line286"></a> * @param {string} uri The URI to examine.
<a name="line287"></a> * @return {?string} The decoded user info, or null if none.
<a name="line288"></a> */
<a name="line289"></a>goog.uri.utils.getUserInfo = function(uri) {
<a name="line290"></a>  return goog.uri.utils.decodeIfPossible_(
<a name="line291"></a>      goog.uri.utils.getUserInfoEncoded(uri));
<a name="line292"></a>};
<a name="line293"></a>
<a name="line294"></a>
<a name="line295"></a>/**
<a name="line296"></a> * @param {string} uri The URI to examine.
<a name="line297"></a> * @return {?string} The domain name still encoded, or null if none.
<a name="line298"></a> */
<a name="line299"></a>goog.uri.utils.getDomainEncoded = function(uri) {
<a name="line300"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line301"></a>      goog.uri.utils.ComponentIndex.DOMAIN, uri);
<a name="line302"></a>};
<a name="line303"></a>
<a name="line304"></a>
<a name="line305"></a>/**
<a name="line306"></a> * @param {string} uri The URI to examine.
<a name="line307"></a> * @return {?string} The decoded domain, or null if none.
<a name="line308"></a> */
<a name="line309"></a>goog.uri.utils.getDomain = function(uri) {
<a name="line310"></a>  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri));
<a name="line311"></a>};
<a name="line312"></a>
<a name="line313"></a>
<a name="line314"></a>/**
<a name="line315"></a> * @param {string} uri The URI to examine.
<a name="line316"></a> * @return {?number} The port number, or null if none.
<a name="line317"></a> */
<a name="line318"></a>goog.uri.utils.getPort = function(uri) {
<a name="line319"></a>  // Coerce to a number.  If the result of getComponentByIndex_ is null or
<a name="line320"></a>  // non-numeric, the number coersion yields NaN.  This will then return
<a name="line321"></a>  // null for all non-numeric cases (though also zero, which isn&#39;t a relevant
<a name="line322"></a>  // port number).
<a name="line323"></a>  return Number(goog.uri.utils.getComponentByIndex_(
<a name="line324"></a>      goog.uri.utils.ComponentIndex.PORT, uri)) || null;
<a name="line325"></a>};
<a name="line326"></a>
<a name="line327"></a>
<a name="line328"></a>/**
<a name="line329"></a> * @param {string} uri The URI to examine.
<a name="line330"></a> * @return {?string} The path still encoded, or null if none. Includes the
<a name="line331"></a> *     leading slash, if any.
<a name="line332"></a> */
<a name="line333"></a>goog.uri.utils.getPathEncoded = function(uri) {
<a name="line334"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line335"></a>      goog.uri.utils.ComponentIndex.PATH, uri);
<a name="line336"></a>};
<a name="line337"></a>
<a name="line338"></a>
<a name="line339"></a>/**
<a name="line340"></a> * @param {string} uri The URI to examine.
<a name="line341"></a> * @return {?string} The decoded path, or null if none.  Includes the leading
<a name="line342"></a> *     slash, if any.
<a name="line343"></a> */
<a name="line344"></a>goog.uri.utils.getPath = function(uri) {
<a name="line345"></a>  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri));
<a name="line346"></a>};
<a name="line347"></a>
<a name="line348"></a>
<a name="line349"></a>/**
<a name="line350"></a> * @param {string} uri The URI to examine.
<a name="line351"></a> * @return {?string} The query data still encoded, or null if none.  Does not
<a name="line352"></a> *     include the question mark itself.
<a name="line353"></a> */
<a name="line354"></a>goog.uri.utils.getQueryData = function(uri) {
<a name="line355"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line356"></a>      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
<a name="line357"></a>};
<a name="line358"></a>
<a name="line359"></a>
<a name="line360"></a>/**
<a name="line361"></a> * @param {string} uri The URI to examine.
<a name="line362"></a> * @return {?string} The fragment identifier, or null if none.  Does not
<a name="line363"></a> *     include the hash mark itself.
<a name="line364"></a> */
<a name="line365"></a>goog.uri.utils.getFragmentEncoded = function(uri) {
<a name="line366"></a>  // The hash mark may not appear in any other part of the URL.
<a name="line367"></a>  var hashIndex = uri.indexOf(&#39;#&#39;);
<a name="line368"></a>  return hashIndex &lt; 0 ? null : uri.substr(hashIndex + 1);
<a name="line369"></a>};
<a name="line370"></a>
<a name="line371"></a>
<a name="line372"></a>/**
<a name="line373"></a> * @param {string} uri The URI to examine.
<a name="line374"></a> * @return {?string} The decoded fragment identifier, or null if none.  Does
<a name="line375"></a> *     not include the hash mark.
<a name="line376"></a> */
<a name="line377"></a>goog.uri.utils.getFragment = function(uri) {
<a name="line378"></a>  return goog.uri.utils.decodeIfPossible_(
<a name="line379"></a>      goog.uri.utils.getFragmentEncoded(uri));
<a name="line380"></a>};
<a name="line381"></a>
<a name="line382"></a>
<a name="line383"></a>/**
<a name="line384"></a> * Extracts everything up to the port of the URI.
<a name="line385"></a> * @param {string} uri The URI string.
<a name="line386"></a> * @return {string} Everything up to and including the port.
<a name="line387"></a> */
<a name="line388"></a>goog.uri.utils.getHost = function(uri) {
<a name="line389"></a>  var pieces = goog.uri.utils.split(uri);
<a name="line390"></a>  return goog.uri.utils.buildFromEncodedParts(
<a name="line391"></a>      pieces[goog.uri.utils.ComponentIndex.SCHEME],
<a name="line392"></a>      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
<a name="line393"></a>      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
<a name="line394"></a>      pieces[goog.uri.utils.ComponentIndex.PORT]);
<a name="line395"></a>};
<a name="line396"></a>
<a name="line397"></a>
<a name="line398"></a>/**
<a name="line399"></a> * Extracts the path of the URL and everything after.
<a name="line400"></a> * @param {string} uri The URI string.
<a name="line401"></a> * @return {?string} The URI, starting at the path and including the query
<a name="line402"></a> *     parameters and fragment identifier.
<a name="line403"></a> */
<a name="line404"></a>goog.uri.utils.getPathAndAfter = function(uri) {
<a name="line405"></a>  var pieces = goog.uri.utils.split(uri);
<a name="line406"></a>  return goog.uri.utils.buildFromEncodedParts(null, null, null, null,
<a name="line407"></a>      pieces[goog.uri.utils.ComponentIndex.PATH],
<a name="line408"></a>      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
<a name="line409"></a>      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
<a name="line410"></a>};
<a name="line411"></a>
<a name="line412"></a>
<a name="line413"></a>/**
<a name="line414"></a> * Gets the URI with the fragment identifier removed.
<a name="line415"></a> * @param {string} uri The URI to examine.
<a name="line416"></a> * @return {string} Everything preceding the hash mark.
<a name="line417"></a> */
<a name="line418"></a>goog.uri.utils.removeFragment = function(uri) {
<a name="line419"></a>  // The hash mark may not appear in any other part of the URL.
<a name="line420"></a>  var hashIndex = uri.indexOf(&#39;#&#39;);
<a name="line421"></a>  return hashIndex &lt; 0 ? uri : uri.substr(0, hashIndex);
<a name="line422"></a>};
<a name="line423"></a>
<a name="line424"></a>
<a name="line425"></a>/**
<a name="line426"></a> * Ensures that two URI&#39;s have the exact same domain, scheme, and port.
<a name="line427"></a> *
<a name="line428"></a> * Unlike the version in goog.Uri, this checks protocol, and therefore is
<a name="line429"></a> * suitable for checking against the browser&#39;s same-origin policy.
<a name="line430"></a> *
<a name="line431"></a> * @param {string} uri1 The first URI.
<a name="line432"></a> * @param {string} uri2 The second URI.
<a name="line433"></a> * @return {boolean} Whether they have the same domain and port.
<a name="line434"></a> */
<a name="line435"></a>goog.uri.utils.haveSameDomain = function(uri1, uri2) {
<a name="line436"></a>  var pieces1 = goog.uri.utils.split(uri1);
<a name="line437"></a>  var pieces2 = goog.uri.utils.split(uri2);
<a name="line438"></a>  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
<a name="line439"></a>             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &amp;&amp;
<a name="line440"></a>         pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
<a name="line441"></a>             pieces2[goog.uri.utils.ComponentIndex.SCHEME] &amp;&amp;
<a name="line442"></a>         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
<a name="line443"></a>             pieces2[goog.uri.utils.ComponentIndex.PORT];
<a name="line444"></a>};
<a name="line445"></a>
<a name="line446"></a>
<a name="line447"></a>/**
<a name="line448"></a> * Asserts that there are no fragment or query identifiers, only in uncompiled
<a name="line449"></a> * mode.
<a name="line450"></a> * @param {string} uri The URI to examine.
<a name="line451"></a> * @private
<a name="line452"></a> */
<a name="line453"></a>goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
<a name="line454"></a>  // NOTE: would use goog.asserts here, but jscompiler doesn&#39;t know that
<a name="line455"></a>  // indexOf has no side effects.
<a name="line456"></a>  if (goog.DEBUG &amp;&amp; (uri.indexOf(&#39;#&#39;) &gt;= 0 || uri.indexOf(&#39;?&#39;) &gt;= 0)) {
<a name="line457"></a>    throw Error(&#39;goog.uri.utils: Fragment or query identifiers are not &#39; +
<a name="line458"></a>        &#39;supported: [&#39; + uri + &#39;]&#39;);
<a name="line459"></a>  }
<a name="line460"></a>};
<a name="line461"></a>
<a name="line462"></a>
<a name="line463"></a>/**
<a name="line464"></a> * Supported query parameter values by the parameter serializing utilities.
<a name="line465"></a> *
<a name="line466"></a> * If a value is null or undefined, the key-value pair is skipped, as an easy
<a name="line467"></a> * way to omit parameters conditionally.  Non-array parameters are converted
<a name="line468"></a> * to a string and URI encoded.  Array values are expanded into multiple
<a name="line469"></a> * &amp;key=value pairs, with each element stringized and URI-encoded.
<a name="line470"></a> *
<a name="line471"></a> * @type {*}
<a name="line472"></a> */
<a name="line473"></a>goog.uri.utils.QueryValue = goog.typedef;
<a name="line474"></a>
<a name="line475"></a>
<a name="line476"></a>/**
<a name="line477"></a> * An array representing a set of query parameters with alternating keys
<a name="line478"></a> * and values.
<a name="line479"></a> *
<a name="line480"></a> * Keys are assumed to be URI encoded already and live at even indices.  See
<a name="line481"></a> * goog.uri.utils.QueryValue for details on how parameter values are encoded.
<a name="line482"></a> *
<a name="line483"></a> * Example:
<a name="line484"></a> * &lt;pre&gt;
<a name="line485"></a> * var data = [
<a name="line486"></a> *   // Simple param: ?name=BobBarker
<a name="line487"></a> *   &#39;name&#39;, &#39;BobBarker&#39;,
<a name="line488"></a> *   // Conditional param -- may be omitted entirely.
<a name="line489"></a> *   &#39;specialDietaryNeeds&#39;, hasDietaryNeeds() ? getDietaryNeeds() : null,
<a name="line490"></a> *   // Multi-valued param: &amp;house=LosAngeles&amp;house=NewYork&amp;house=null
<a name="line491"></a> *   &#39;house&#39;, [&#39;LosAngeles&#39;, &#39;NewYork&#39;, null]
<a name="line492"></a> * ];
<a name="line493"></a> * &lt;/pre&gt;
<a name="line494"></a> *
<a name="line495"></a> * @type {!Array.&lt;string|goog.uri.utils.QueryValue&gt;}
<a name="line496"></a> */
<a name="line497"></a>goog.uri.utils.QueryArray = goog.typedef;
<a name="line498"></a>
<a name="line499"></a>
<a name="line500"></a>/**
<a name="line501"></a> * Appends a URI and query data in a string buffer with special preconditions.
<a name="line502"></a> *
<a name="line503"></a> * Internal implementation utility, performing very few object allocations.
<a name="line504"></a> *
<a name="line505"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer.  The first element
<a name="line506"></a> *     must be the base URI, and may have a fragment identifier.  If the array
<a name="line507"></a> *     contains more than one element, the second element must be an ampersand,
<a name="line508"></a> *     and may be overwritten, depending on the base URI.  Undefined elements
<a name="line509"></a> *     are treated as empty-string.
<a name="line510"></a> * @return {string} The concatenated URI and query data.
<a name="line511"></a> * @private
<a name="line512"></a> */
<a name="line513"></a>goog.uri.utils.appendQueryData_ = function(buffer) {
<a name="line514"></a>  if (buffer[1]) {
<a name="line515"></a>    // At least one query parameter was added.  We need to check the
<a name="line516"></a>    // punctuation mark, which is currently an ampersand, and also make sure
<a name="line517"></a>    // there aren&#39;t any interfering fragment identifiers.
<a name="line518"></a>    var baseUri = /** @type {string} */ (buffer[0]);
<a name="line519"></a>    var hashIndex = baseUri.indexOf(&#39;#&#39;);
<a name="line520"></a>    if (hashIndex &gt;= 0) {
<a name="line521"></a>      // Move the fragment off the base part of the URI into the end.
<a name="line522"></a>      buffer.push(baseUri.substr(hashIndex));
<a name="line523"></a>      buffer[0] = baseUri = baseUri.substr(0, hashIndex);
<a name="line524"></a>    }
<a name="line525"></a>    var questionIndex = baseUri.indexOf(&#39;?&#39;);
<a name="line526"></a>    if (questionIndex &lt; 0) {
<a name="line527"></a>      // No question mark, so we need a question mark instead of an ampersand.
<a name="line528"></a>      buffer[1] = &#39;?&#39;;
<a name="line529"></a>    } else if (questionIndex == baseUri.length - 1) {
<a name="line530"></a>      // Question mark is the very last character of the existing URI, so don&#39;t
<a name="line531"></a>      // append an additional delimiter.
<a name="line532"></a>      buffer[1] = undefined;
<a name="line533"></a>    }
<a name="line534"></a>  }
<a name="line535"></a>
<a name="line536"></a>  return buffer.join(&#39;&#39;);
<a name="line537"></a>};
<a name="line538"></a>
<a name="line539"></a>
<a name="line540"></a>/**
<a name="line541"></a> * Appends key=value pairs to an array, supporting multi-valued objects.
<a name="line542"></a> * @param {string} key The key prefix.
<a name="line543"></a> * @param {goog.uri.utils.QueryValue} value The value to serialize.
<a name="line544"></a> * @param {!Array.&lt;string&gt;} pairs The array to which the &#39;key=value&#39; strings
<a name="line545"></a> *     should be appended.
<a name="line546"></a> * @private
<a name="line547"></a> */
<a name="line548"></a>goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
<a name="line549"></a>  if (goog.isArray(value)) {
<a name="line550"></a>    // It&#39;s an array, so append all elements.  Here, we must convince
<a name="line551"></a>    // jscompiler that it is, indeed, an array.
<a name="line552"></a>    value = /** @type {Array} */ (value);
<a name="line553"></a>    for (var j = 0; j &lt; value.length; j++) {
<a name="line554"></a>      pairs.push(&#39;&amp;&#39;, key, &#39;=&#39;, goog.string.urlEncode(value[j]));
<a name="line555"></a>    }
<a name="line556"></a>  } else if (value != null) {
<a name="line557"></a>    // Not null or undefined, so safe to append.
<a name="line558"></a>    pairs.push(&#39;&amp;&#39;, key, &#39;=&#39;, goog.string.urlEncode(value));
<a name="line559"></a>  }
<a name="line560"></a>};
<a name="line561"></a>
<a name="line562"></a>
<a name="line563"></a>/**
<a name="line564"></a> * Builds a buffer of query data from a sequence of alternating keys and values.
<a name="line565"></a> *
<a name="line566"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer to append to.  The
<a name="line567"></a> *     first element appended will be an &#39;&amp;&#39;, and may be replaced by the caller.
<a name="line568"></a> * @param {goog.uri.utils.QueryArray|Arguments} keysAndValues An array with
<a name="line569"></a> *     alternating keys and values -- see the typedef.
<a name="line570"></a> * @param {number} opt_startIndex A start offset into the arary, defaults to 0.
<a name="line571"></a> * @return {!Array.&lt;string|undefined&gt;} The buffer argument.
<a name="line572"></a> * @private
<a name="line573"></a> */
<a name="line574"></a>goog.uri.utils.buildQueryDataBuffer_ = function(
<a name="line575"></a>    buffer, keysAndValues, opt_startIndex) {
<a name="line576"></a>  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0),
<a name="line577"></a>      0) % 2 == 0, &#39;goog.uri.utils: Key/value lists must be even in length.&#39;);
<a name="line578"></a>
<a name="line579"></a>  for (var i = opt_startIndex || 0; i &lt; keysAndValues.length; i += 2) {
<a name="line580"></a>    goog.uri.utils.appendKeyValuePairs_(
<a name="line581"></a>        keysAndValues[i], keysAndValues[i + 1], buffer);
<a name="line582"></a>  }
<a name="line583"></a>
<a name="line584"></a>  return buffer;
<a name="line585"></a>};
<a name="line586"></a>
<a name="line587"></a>
<a name="line588"></a>/**
<a name="line589"></a> * Builds a query data string from a sequence of alternating keys and values.
<a name="line590"></a> *
<a name="line591"></a> * Currently generates &quot;&amp;key=&amp;&quot; for empty args; there is no way to generate
<a name="line592"></a> * &quot;&amp;key&amp;&quot; arguments with no equal sign.
<a name="line593"></a> *
<a name="line594"></a> * @param {goog.uri.utils.QueryArray} keysAndValues Alternating keys and
<a name="line595"></a> *     values.  See the typedef.
<a name="line596"></a> * @param {number} opt_startIndex A start offset into the arary, defaults to 0.
<a name="line597"></a> * @return {string} The encoded query string, in the for &#39;a=1&amp;b=2&#39;.
<a name="line598"></a> */
<a name="line599"></a>goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
<a name="line600"></a>  var buffer = goog.uri.utils.buildQueryDataBuffer_(
<a name="line601"></a>      [], keysAndValues, opt_startIndex);
<a name="line602"></a>  buffer[0] = &#39;&#39;; // Remove the leading ampersand.
<a name="line603"></a>  return buffer.join(&#39;&#39;);
<a name="line604"></a>};
<a name="line605"></a>
<a name="line606"></a>
<a name="line607"></a>/**
<a name="line608"></a> * Builds a buffer of query data from a map.
<a name="line609"></a> *
<a name="line610"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer to append to.  The
<a name="line611"></a> *     first element appended will be an &#39;&amp;&#39;, and may be replaced by the caller.
<a name="line612"></a> * @param {Object.&lt;goog.uri.utils.QueryValue&gt;} map An object where keys are
<a name="line613"></a> *     URI-encoded parameter keys, and the values conform to the contract
<a name="line614"></a> *     specified in the goog.uri.utils.QueryValue typedef.
<a name="line615"></a> * @return {!Array.&lt;string|undefined&gt;} The buffer argument.
<a name="line616"></a> * @private
<a name="line617"></a> */
<a name="line618"></a>goog.uri.utils.buildQueryDataBufferFromMap_ = function(buffer, map) {
<a name="line619"></a>  for (var key in map) {
<a name="line620"></a>    goog.uri.utils.appendKeyValuePairs_(key, map[key], buffer);
<a name="line621"></a>  }
<a name="line622"></a>
<a name="line623"></a>  return buffer;
<a name="line624"></a>};
<a name="line625"></a>
<a name="line626"></a>
<a name="line627"></a>/**
<a name="line628"></a> * Builds a query data string from a map.
<a name="line629"></a> *
<a name="line630"></a> * Currently generates &quot;&amp;key=&amp;&quot; for empty args; there is no way to generate
<a name="line631"></a> * &quot;&amp;key&amp;&quot; arguments with no equal sign.
<a name="line632"></a> *
<a name="line633"></a> * @param {Object} map An object where keys are URI-encoded parameter keys,
<a name="line634"></a> *     and the values are arbitrary types or arrays.  Keys with a null value
<a name="line635"></a> *     are dropped.
<a name="line636"></a> * @return {string} The encoded query string, in the for &#39;a=1&amp;b=2&#39;.
<a name="line637"></a> */
<a name="line638"></a>goog.uri.utils.buildQueryDataFromMap = function(map) {
<a name="line639"></a>  var buffer = goog.uri.utils.buildQueryDataBufferFromMap_([], map);
<a name="line640"></a>  buffer[0] = &#39;&#39;;
<a name="line641"></a>  return buffer.join(&#39;&#39;);
<a name="line642"></a>};
<a name="line643"></a>
<a name="line644"></a>
<a name="line645"></a>/**
<a name="line646"></a> * Appends URI parameters to an existing URI.
<a name="line647"></a> *
<a name="line648"></a> * The variable arguments may contain alternating keys and values.  Keys are
<a name="line649"></a> * assumed to be already URI encoded.  The values should not be URI-encoded,
<a name="line650"></a> * and will instead be encoded by this function.
<a name="line651"></a> * &lt;pre&gt;
<a name="line652"></a> * appendParams(&#39;http://www.foo.com?existing=true&#39;,
<a name="line653"></a> *     &#39;key1&#39;, &#39;value1&#39;,
<a name="line654"></a> *     &#39;key2&#39;, &#39;value?willBeEncoded&#39;,
<a name="line655"></a> *     &#39;key3&#39;, [&#39;valueA&#39;, &#39;valueB&#39;, &#39;valueC&#39;],
<a name="line656"></a> *     &#39;key4&#39;, null);
<a name="line657"></a> * result: &#39;http://www.foo.com?existing=true&amp;&#39; +
<a name="line658"></a> *     &#39;key1=value1&amp;&#39; +
<a name="line659"></a> *     &#39;key2=value%3FwillBeEncoded&amp;&#39; +
<a name="line660"></a> *     &#39;key3=valueA&amp;key3=valueB&amp;key3=valueC&#39;
<a name="line661"></a> * &lt;/pre&gt;
<a name="line662"></a> *
<a name="line663"></a> * A single call to this function will not exhibit quadratic behavior in IE,
<a name="line664"></a> * whereas multiple repeated calls may, although the effect is limited by
<a name="line665"></a> * fact that URL&#39;s generally can&#39;t exceed 2kb.
<a name="line666"></a> *
<a name="line667"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line668"></a> * @param {...(goog.uri.utils.QueryArray|string|goog.uri.utils.QueryValue)} var_args
<a name="line669"></a> *     An array or argument list conforming to goog.uri.utils.QueryArray.
<a name="line670"></a> * @return {string} The URI with all query parameters added.
<a name="line671"></a> */
<a name="line672"></a>goog.uri.utils.appendParams = function(uri, var_args) {
<a name="line673"></a>  return goog.uri.utils.appendQueryData_(
<a name="line674"></a>      arguments.length == 2 ?
<a name="line675"></a>      goog.uri.utils.buildQueryDataBuffer_([uri], arguments[1], 0) :
<a name="line676"></a>      goog.uri.utils.buildQueryDataBuffer_([uri], arguments, 1));
<a name="line677"></a>};
<a name="line678"></a>
<a name="line679"></a>
<a name="line680"></a>/**
<a name="line681"></a> * Appends query parameters from a map.
<a name="line682"></a> *
<a name="line683"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line684"></a> * @param {Object} map An object where keys are URI-encoded parameter keys,
<a name="line685"></a> *     and the values are arbitrary types or arrays.  Keys with a null value
<a name="line686"></a> *     are dropped.
<a name="line687"></a> * @return {string} The new parameters.
<a name="line688"></a> */
<a name="line689"></a>goog.uri.utils.appendParamsFromMap = function(uri, map) {
<a name="line690"></a>  return goog.uri.utils.appendQueryData_(
<a name="line691"></a>      goog.uri.utils.buildQueryDataBufferFromMap_([uri], map));
<a name="line692"></a>};
<a name="line693"></a>
<a name="line694"></a>
<a name="line695"></a>/**
<a name="line696"></a> * Appends a single URI parameter.
<a name="line697"></a> *
<a name="line698"></a> * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
<a name="line699"></a> * way string append works, though it should be limited given the 2kb limit.
<a name="line700"></a> *
<a name="line701"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line702"></a> * @param {string} key The key, which must already be URI encoded.
<a name="line703"></a> * @param {*} value The value, which will be stringized and encoded (assumed
<a name="line704"></a> *     not already to be encoded).
<a name="line705"></a> * @return {string} The URI with the query parameter added.
<a name="line706"></a> */
<a name="line707"></a>goog.uri.utils.appendParam = function(uri, key, value) {
<a name="line708"></a>  return goog.uri.utils.appendQueryData_(
<a name="line709"></a>      [uri, &#39;&amp;&#39;, key, &#39;=&#39;, goog.string.urlEncode(value)]);
<a name="line710"></a>};
<a name="line711"></a>
<a name="line712"></a>
<a name="line713"></a>/**
<a name="line714"></a> * Finds the next instance of a query parameter with the specified name.
<a name="line715"></a> *
<a name="line716"></a> * Does not instantiate any objects.
<a name="line717"></a> *
<a name="line718"></a> * @param {string} uri The URI to search.  May contain a fragment identifier
<a name="line719"></a> *     if opt_hashIndex is specified.
<a name="line720"></a> * @param {number} startIndex The index to begin searching for the key at.  A
<a name="line721"></a> *     match may be found even if this is one character after the ampersand.
<a name="line722"></a> * @param {string} keyEncoded The URI-encoded key.
<a name="line723"></a> * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
<a name="line724"></a> *     mark is present, it should be its index, otherwise it should be the
<a name="line725"></a> *     length of the string.
<a name="line726"></a> * @return {number} The position of the first character in the key&#39;s name,
<a name="line727"></a> *     immediately after either a question mark or a dot.
<a name="line728"></a> * @private
<a name="line729"></a> */
<a name="line730"></a>goog.uri.utils.findParam_ = function(
<a name="line731"></a>    uri, startIndex, keyEncoded, hashOrEndIndex) {
<a name="line732"></a>  var index = startIndex;
<a name="line733"></a>  var keyLength = keyEncoded.length;
<a name="line734"></a>
<a name="line735"></a>  // Search for the key itself and post-filter for surronuding punctuation,
<a name="line736"></a>  // rather than expensively building a regexp.
<a name="line737"></a>  while ((index = uri.indexOf(keyEncoded, index)) &gt;= 0 &amp;&amp;
<a name="line738"></a>      index &lt; hashOrEndIndex) {
<a name="line739"></a>    var precedingChar = uri.charCodeAt(index - 1);
<a name="line740"></a>    // Ensure that the preceding character is &#39;&amp;&#39; or &#39;?&#39;.
<a name="line741"></a>    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
<a name="line742"></a>        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
<a name="line743"></a>      // Ensure the following character is &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, or NaN
<a name="line744"></a>      // (end of string).
<a name="line745"></a>      var followingChar = uri.charCodeAt(index + keyLength);
<a name="line746"></a>      if (!followingChar ||
<a name="line747"></a>          followingChar == goog.uri.utils.CharCode_.EQUAL ||
<a name="line748"></a>          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
<a name="line749"></a>          followingChar == goog.uri.utils.CharCode_.HASH) {
<a name="line750"></a>        return index;
<a name="line751"></a>      }
<a name="line752"></a>    }
<a name="line753"></a>    index += keyLength + 1;
<a name="line754"></a>  }
<a name="line755"></a>
<a name="line756"></a>  return -1;
<a name="line757"></a>};
<a name="line758"></a>
<a name="line759"></a>
<a name="line760"></a>/**
<a name="line761"></a> * Regular expression for finding a hash mark or end of string.
<a name="line762"></a> * @type {RegExp}
<a name="line763"></a> * @private
<a name="line764"></a> */
<a name="line765"></a>goog.uri.utils.hashOrEndRe_ = /#|$/;
<a name="line766"></a>
<a name="line767"></a>
<a name="line768"></a>/**
<a name="line769"></a> * Determines if the URI contains a specific key.
<a name="line770"></a> *
<a name="line771"></a> * Performs no object instantiations.
<a name="line772"></a> *
<a name="line773"></a> * @param {string} uri The URI to process.  May contain a fragment
<a name="line774"></a> *     identifier.
<a name="line775"></a> * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
<a name="line776"></a> * @return {boolean} Whether the key is present.
<a name="line777"></a> */
<a name="line778"></a>goog.uri.utils.hasParam = function(uri, keyEncoded) {
<a name="line779"></a>  return goog.uri.utils.findParam_(uri, 0, keyEncoded,
<a name="line780"></a>      uri.search(goog.uri.utils.hashOrEndRe_)) &gt;= 0;
<a name="line781"></a>};
<a name="line782"></a>
<a name="line783"></a>
<a name="line784"></a>/**
<a name="line785"></a> * Gets the first value of a query parameter.
<a name="line786"></a> * @param {string} uri The URI to process.  May contain a fragment.
<a name="line787"></a> * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
<a name="line788"></a> * @return {?string} The first value of the parameter (URI-decoded), or null
<a name="line789"></a> *     if the parameter is not found.
<a name="line790"></a> */
<a name="line791"></a>goog.uri.utils.getParamValue = function(uri, keyEncoded) {
<a name="line792"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line793"></a>  var foundIndex = goog.uri.utils.findParam_(
<a name="line794"></a>      uri, 0, keyEncoded, hashOrEndIndex);
<a name="line795"></a>
<a name="line796"></a>  if (foundIndex &lt; 0) {
<a name="line797"></a>    return null;
<a name="line798"></a>  } else {
<a name="line799"></a>    var endPosition = uri.indexOf(&#39;&amp;&#39;, foundIndex);
<a name="line800"></a>    if (endPosition &lt; 0 || endPosition &gt; hashOrEndIndex) {
<a name="line801"></a>      endPosition = hashOrEndIndex;
<a name="line802"></a>    }
<a name="line803"></a>    // Progress forth to the end of the &quot;key=&quot; or &quot;key&amp;&quot; substring.
<a name="line804"></a>    foundIndex += keyEncoded.length + 1;
<a name="line805"></a>    // Use substr, because it (unlike substring) will return empty string
<a name="line806"></a>    // if foundIndex &gt; endPosition.
<a name="line807"></a>    return goog.string.urlDecode(
<a name="line808"></a>        uri.substr(foundIndex, endPosition - foundIndex));
<a name="line809"></a>  }
<a name="line810"></a>};
<a name="line811"></a>
<a name="line812"></a>
<a name="line813"></a>/**
<a name="line814"></a> * Gets all values of a query parameter.
<a name="line815"></a> * @param {string} uri The URI to process.  May contain a framgnet.
<a name="line816"></a> * @param {string} keyEncoded The URI-encoded key.  Case-snsitive.
<a name="line817"></a> * @return {!Array.&lt;string&gt;} All URI-decoded values with the given key.
<a name="line818"></a> *     If the key is not found, this will have length 0, but never be null.
<a name="line819"></a> */
<a name="line820"></a>goog.uri.utils.getParamValues = function(uri, keyEncoded) {
<a name="line821"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line822"></a>  var position = 0;
<a name="line823"></a>  var foundIndex;
<a name="line824"></a>  var result = [];
<a name="line825"></a>
<a name="line826"></a>  while ((foundIndex = goog.uri.utils.findParam_(
<a name="line827"></a>      uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {
<a name="line828"></a>    // Find where this parameter ends, either the &#39;&amp;&#39; or the end of the
<a name="line829"></a>    // query parameters.
<a name="line830"></a>    position = uri.indexOf(&#39;&amp;&#39;, foundIndex);
<a name="line831"></a>    if (position &lt; 0 || position &gt; hashOrEndIndex) {
<a name="line832"></a>      position = hashOrEndIndex;
<a name="line833"></a>    }
<a name="line834"></a>
<a name="line835"></a>    // Progress forth to the end of the &quot;key=&quot; or &quot;key&amp;&quot; substring.
<a name="line836"></a>    foundIndex += keyEncoded.length + 1;
<a name="line837"></a>    // Use substr, because it (unlike substring) will return empty string
<a name="line838"></a>    // if foundIndex &gt; position.
<a name="line839"></a>    result.push(goog.string.urlDecode(uri.substr(
<a name="line840"></a>        foundIndex, position - foundIndex)));
<a name="line841"></a>  }
<a name="line842"></a>
<a name="line843"></a>  return result;
<a name="line844"></a>};
<a name="line845"></a>
<a name="line846"></a>
<a name="line847"></a>/**
<a name="line848"></a> * Regexp to find trailing question marks and ampersands.
<a name="line849"></a> * @type {RegExp}
<a name="line850"></a> * @private
<a name="line851"></a> */
<a name="line852"></a>goog.uri.utils.trailingQueryPunctuationRe_ = /[?&amp;]($|#)/;
<a name="line853"></a>
<a name="line854"></a>
<a name="line855"></a>/**
<a name="line856"></a> * Removes all instances of a query parameter.
<a name="line857"></a> * @param {string} uri The URI to process.  Must not contain a fragment.
<a name="line858"></a> * @param {string} keyEncoded The URI-encoded key.
<a name="line859"></a> * @return {string} The URI with all instances of the parameter removed.
<a name="line860"></a> */
<a name="line861"></a>goog.uri.utils.removeParam = function(uri, keyEncoded) {
<a name="line862"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line863"></a>  var position = 0;
<a name="line864"></a>  var foundIndex;
<a name="line865"></a>  var buffer = [];
<a name="line866"></a>
<a name="line867"></a>  // Look for a query parameter.
<a name="line868"></a>  while ((foundIndex = goog.uri.utils.findParam_(
<a name="line869"></a>      uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {
<a name="line870"></a>    // Get the portion of the query string up to, but not including, the ?
<a name="line871"></a>    // or &amp; starting the parameter.
<a name="line872"></a>    buffer.push(uri.substring(position, foundIndex));
<a name="line873"></a>    // Progress to immediately after the &#39;&amp;&#39;.  If not found, go to the end.
<a name="line874"></a>    // Avoid including the hash mark.
<a name="line875"></a>    position = Math.min((uri.indexOf(&#39;&amp;&#39;, foundIndex) + 1) || hashOrEndIndex,
<a name="line876"></a>        hashOrEndIndex);
<a name="line877"></a>  }
<a name="line878"></a>
<a name="line879"></a>  // Append everything that is remaining.
<a name="line880"></a>  buffer.push(uri.substr(position));
<a name="line881"></a>
<a name="line882"></a>  // Join the buffer, and remove trailing punctuation that remains.
<a name="line883"></a>  return buffer.join(&#39;&#39;).replace(
<a name="line884"></a>      goog.uri.utils.trailingQueryPunctuationRe_, &#39;$1&#39;);
<a name="line885"></a>};
<a name="line886"></a>
<a name="line887"></a>
<a name="line888"></a>/**
<a name="line889"></a> * Replaces all existing definitions of a parameter with a single definition.
<a name="line890"></a> *
<a name="line891"></a> * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
<a name="line892"></a> * way string append works, though it should be limited given the 2kb limit.
<a name="line893"></a> *
<a name="line894"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line895"></a> * @param {string} keyEncoded The key, which must already be URI encoded.
<a name="line896"></a> * @param {*} value The value, which will be stringized and encoded (assumed
<a name="line897"></a> *     not already to be encoded).
<a name="line898"></a> * @return {string} The URI with the query parameter added.
<a name="line899"></a> */
<a name="line900"></a>goog.uri.utils.setParam = function(uri, keyEncoded, value) {
<a name="line901"></a>  return goog.uri.utils.appendParam(
<a name="line902"></a>      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
<a name="line903"></a>};
<a name="line904"></a>
<a name="line905"></a>
<a name="line906"></a>/**
<a name="line907"></a> * Generates a URI path using a given URI and a path with checks to
<a name="line908"></a> * prevent consecutive &quot;//&quot;. The baseUri passed in must not contain
<a name="line909"></a> * query or fragment identifiers. The path to append may not contain query or
<a name="line910"></a> * fragment identifiers.
<a name="line911"></a> *
<a name="line912"></a> * @param {string} baseUri URI to use as the base.
<a name="line913"></a> * @param {string} path Path to append.
<a name="line914"></a> * @return {string} Updated URI.
<a name="line915"></a> */
<a name="line916"></a>goog.uri.utils.appendPath = function(baseUri, path) {
<a name="line917"></a>  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);
<a name="line918"></a>
<a name="line919"></a>  // Remove any trailing &#39;/&#39;
<a name="line920"></a>  if (goog.string.endsWith(baseUri, &#39;/&#39;)) {
<a name="line921"></a>    baseUri = baseUri.substr(0, baseUri.length - 1);
<a name="line922"></a>  }
<a name="line923"></a>  // Remove any leading &#39;/&#39;
<a name="line924"></a>  if (goog.string.startsWith(path, &#39;/&#39;)) {
<a name="line925"></a>    path = path.substr(1);
<a name="line926"></a>  }
<a name="line927"></a>  return goog.string.buildString(baseUri, &#39;/&#39;, path);
<a name="line928"></a>};
<a name="line929"></a>
<a name="line930"></a>
<a name="line931"></a>/**
<a name="line932"></a> * Standard supported query parameters.
<a name="line933"></a> * @enum {string}
<a name="line934"></a> */
<a name="line935"></a>goog.uri.utils.StandardQueryParam = {
<a name="line936"></a>
<a name="line937"></a>  /** Unused parameter for unique-ifying. */
<a name="line938"></a>  RANDOM: &#39;zx&#39;
<a name="line939"></a>};
<a name="line940"></a>
<a name="line941"></a>
<a name="line942"></a>/**
<a name="line943"></a> * Sets the zx parameter of a URI to a random value.
<a name="line944"></a> * @param {string} uri Any URI.
<a name="line945"></a> * @return {string} That URI with the &quot;zx&quot; parameter added or replaced to
<a name="line946"></a> *     contain a random string.
<a name="line947"></a> */
<a name="line948"></a>goog.uri.utils.makeUnique = function(uri) {
<a name="line949"></a>  return goog.uri.utils.setParam(uri,
<a name="line950"></a>      goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());
<a name="line951"></a>};
</pre>


</body>
</html>
