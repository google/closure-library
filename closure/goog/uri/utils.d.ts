//!! generated by clutz.
// Generated from third_party/closure/goog/uri/utils.js
declare namespace ಠ_ಠ.clutz.goog.uri.utils {
  /**
   * Appends a single URI parameter.
   *
   * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
   * way string append works, though it should be limited given the 2kb limit.
   * @param uri The original URI, which may already have query data.
   * @param key The key, which must already be URI encoded.
   * @param opt_value The value, which will be stringized and encoded (assumed not already to be encoded).  If omitted, undefined, or null, the key will be added as a valueless parameter.
   */
  function appendParam (uri : string , key : string , opt_value ? : any ) : string ;
  /**
   * Appends URI parameters to an existing URI.
   *
   * The variable arguments may contain alternating keys and values.  Keys are
   * assumed to be already URI encoded.  The values should not be URI-encoded,
   * and will instead be encoded by this function.
   * <pre>
   * appendParams('http://www.foo.com?existing=true',
   * 'key1', 'value1',
   * 'key2', 'value?willBeEncoded',
   * 'key3', ['valueA', 'valueB', 'valueC'],
   * 'key4', null);
   * result: 'http://www.foo.com?existing=true&' +
   * 'key1=value1&' +
   * 'key2=value%3FwillBeEncoded&' +
   * 'key3=valueA&key3=valueB&key3=valueC'
   * </pre>
   *
   * A single call to this function will not exhibit quadratic behavior in IE,
   * whereas multiple repeated calls may, although the effect is limited by
   * fact that URL's generally can't exceed 2kb.
   * @param uri The original URI, which may already have query data.
   * @param var_args An array or argument list conforming to goog.uri.utils.QueryArray.
   */
  function appendParams (uri : string ,  ...var_args : any [] ) : string ;
  /**
   * Appends query parameters from a map.
   * @param uri The original URI, which may already have query data.
   * @param map An object where keys are URI-encoded parameter keys, and the values are arbitrary types or arrays. Keys with a null value are dropped.
   */
  function appendParamsFromMap (uri : string , map : { [ /* warning: coerced from ? */ key: string ]: any } ) : string ;
  /**
   * Generates a URI path using a given URI and a path with checks to
   * prevent consecutive "//". The baseUri passed in must not contain
   * query or fragment identifiers. The path to append may not contain query or
   * fragment identifiers.
   * @param baseUri URI to use as the base.
   * @param path Path to append.
   */
  function appendPath (baseUri : string , path : string ) : string ;
  /**
   * Builds a URI string from already-encoded parts.
   *
   * No encoding is performed.  Any component may be omitted as either null or
   * undefined.
   * @param opt_scheme The scheme such as 'http'.
   * @param opt_userInfo The user name before the '@'.
   * @param opt_domain The domain such as 'www.google.com', already URI-encoded.
   * @param opt_port The port number.
   * @param opt_path The path, already URI-encoded.  If it is not empty, it must begin with a slash.
   * @param opt_queryData The URI-encoded query data.
   * @param opt_fragment The URI-encoded fragment identifier.
   */
  function buildFromEncodedParts (opt_scheme ? : string | null , opt_userInfo ? : string | null , opt_domain ? : string | null , opt_port ? : string | number | null , opt_path ? : string | null , opt_queryData ? : string | null , opt_fragment ? : string | null ) : string ;
  /**
   * Builds a query data string from a sequence of alternating keys and values.
   * Currently generates "&key&" for empty args.
   * @param keysAndValues Alternating keys and values. See the QueryArray typedef.
   * @param opt_startIndex A start offset into the arary, defaults to 0.
   */
  function buildQueryData (keysAndValues : ArrayLike < any > , opt_startIndex ? : number ) : string ;
  /**
   * Builds a query data string from a map.
   * Currently generates "&key&" for empty args.
   * @param map An object where keys are URI-encoded parameter keys, and the values are arbitrary types or arrays. Keys with a null value are dropped.
   */
  function buildQueryDataFromMap (map : { [ key: string ]: any } ) : string ;
  function getDomain (uri : string ) : string | null ;
  function getDomainEncoded (uri : string ) : string | null ;
  /**
   * Gets the effective scheme for the URL.  If the URL is relative then the
   * scheme is derived from the page's location.
   * @param uri The URI to examine.
   */
  function getEffectiveScheme (uri : string ) : string ;
  function getFragment (uri : string ) : string | null ;
  function getFragmentEncoded (uri : string ) : string | null ;
  /**
   * Extracts everything up to the port of the URI.
   * @param uri The URI string.
   */
  function getHost (uri : string ) : string ;
  /**
   * Returns the origin for a given URL.
   * @param uri The URI string.
   */
  function getOrigin (uri : string ) : string ;
  /**
   * Gets the first value of a query parameter.
   * @param uri The URI to process.  May contain a fragment.
   * @param keyEncoded The URI-encoded key.  Case-sensitive.
   */
  function getParamValue (uri : string , keyEncoded : string ) : string | null ;
  /**
   * Gets all values of a query parameter.
   * @param uri The URI to process.  May contain a fragment.
   * @param keyEncoded The URI-encoded key.  Case-sensitive.
   */
  function getParamValues (uri : string , keyEncoded : string ) : string [] ;
  function getPath (uri : string ) : string | null ;
  /**
   * Extracts the path of the URL and everything after.
   * @param uri The URI string.
   */
  function getPathAndAfter (uri : string ) : string ;
  function getPathEncoded (uri : string ) : string | null ;
  function getPort (uri : string ) : number | null ;
  function getQueryData (uri : string ) : string | null ;
  function getScheme (uri : string ) : string | null ;
  function getUserInfo (uri : string ) : string | null ;
  function getUserInfoEncoded (uri : string ) : string | null ;
  /**
   * Determines if the URI contains a specific key.
   *
   * Performs no object instantiations.
   * @param uri The URI to process.  May contain a fragment identifier.
   * @param keyEncoded The URI-encoded key.  Case-sensitive.
   */
  function hasParam (uri : string , keyEncoded : string ) : boolean ;
  /**
   * Ensures that two URI's have the exact same domain, scheme, and port.
   *
   * Unlike the version in goog.Uri, this checks protocol, and therefore is
   * suitable for checking against the browser's same-origin policy.
   * @param uri1 The first URI.
   * @param uri2 The second URI.
   */
  function haveSameDomain (uri1 : string , uri2 : string ) : boolean ;
  /**
   * Sets the zx parameter of a URI to a random value.
   * @param uri Any URI.
   */
  function makeUnique (uri : string ) : string ;
  /**
   * Parses encoded query parameters and calls callback function for every
   * parameter found in the string.
   *
   * Missing value of parameter (e.g. “…&key&…”) is treated as if the value was an
   * empty string.  Keys may be empty strings (e.g. “…&=value&…”) which also means
   * that “…&=&…” and “…&&…” will result in an empty key and value.
   * @param encodedQuery Encoded query string excluding question mark at the beginning.
   * @param callback Function called for every parameter found in query string.  The first argument (name) will not be urldecoded (so the function is consistent with buildQueryData), but the second will.  If the parameter has no value (i.e. “=” was not present) the second argument (value) will be an empty string.
   */
  function parseQueryData (encodedQuery : string , callback : (a : string , b : string ) => any ) : void ;
  /**
   * Gets the URI with the fragment identifier removed.
   * @param uri The URI to examine.
   */
  function removeFragment (uri : string ) : string ;
  /**
   * Removes all instances of a query parameter.
   * @param uri The URI to process.  Must not contain a fragment.
   * @param keyEncoded The URI-encoded key.
   */
  function removeParam (uri : string , keyEncoded : string ) : string ;
  function setFragmentEncoded (uri : string , fragment : string | null ) : string ;
  /**
   * Replaces all existing definitions of a parameter with a single definition.
   *
   * Repeated calls to this can exhibit quadratic behavior due to the need to
   * find existing instances and reconstruct the string, though it should be
   * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap
   * to update multiple parameters in bulk.
   * @param uri The original URI, which may already have query data.
   * @param keyEncoded The key, which must already be URI encoded.
   * @param value The value, which will be stringized and encoded (assumed not already to be encoded).
   */
  function setParam (uri : string , keyEncoded : string , value : any ) : string ;
  /**
   * Effeciently set or remove multiple query parameters in a URI. Order of
   * unchanged parameters will not be modified, all updated parameters will be
   * appended to the end of the query. Params with values of null or undefined are
   * removed.
   * @param uri The URI to process.
   * @param params A list of parameters to update. If null or undefined, the param will be removed.
   */
  function setParamsFromMap (uri : string , params : { [ key: string ]: any } ) : string ;
  /**
   * Replaces the path.
   * @param uri URI to use as the base.
   * @param path New path.
   */
  function setPath (uri : string , path : string ) : string ;
  function setUrlPackageSupportLoggingHandler (handler : ( (a : string ) => any ) | null ) : void ;
  /**
   * Splits a URI into its component parts.
   *
   * Each component can be accessed via the component indices; for example:
   * <pre>
   * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];
   * </pre>
   * @param uri The URI string to examine.
   */
  function split (uri : string ) : ( string | undefined ) [] ;
}
// Generated from third_party/closure/goog/uri/utils.js
declare module 'goog:goog.uri.utils' {
  import utils = ಠ_ಠ.clutz.goog.uri.utils;
  export = utils;
  const __clutz_actual_path: 'google3/third_party/closure/goog/uri/utils';
}
declare module 'google3/third_party/closure/goog/uri/utils' {
  import utils = ಠ_ಠ.clutz.goog.uri.utils;
  export = utils;
  const __clutz_actual_namespace: 'goog.uri.utils';
}
// Generated from third_party/closure/goog/uri/utils.js
declare namespace ಠ_ಠ.clutz.goog.uri.utils {
  /**
   * The index of each URI component in the return value of goog.uri.utils.split.
   */
  /**
   * The index of each URI component in the return value of goog.uri.utils.split.
   */
  enum ComponentIndex {
    DOMAIN = 3.0 ,
    FRAGMENT = 7.0 ,
    PATH = 5.0 ,
    PORT = 4.0 ,
    QUERY_DATA = 6.0 ,
    SCHEME = 1.0 ,
    USER_INFO = 2.0 ,
  }
}
// Generated from third_party/closure/goog/uri/utils.js
declare module 'goog:goog.uri.utils.ComponentIndex' {
  import ComponentIndex = ಠ_ಠ.clutz.goog.uri.utils.ComponentIndex;
  export default ComponentIndex;
}
// Generated from third_party/closure/goog/uri/utils.js
declare namespace ಠ_ಠ.clutz.goog.uri.utils {
  /**
   * An array representing a set of query parameters with alternating keys
   * and values.
   *
   * Keys are assumed to be URI encoded already and live at even indices.  See
   * goog.uri.utils.QueryValue for details on how parameter values are encoded.
   *
   * Example:
   * <pre>
   * var data = [
   * // Simple param: ?name=BobBarker
   * 'name', 'BobBarker',
   * // Conditional param -- may be omitted entirely.
   * 'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,
   * // Multi-valued param: &house=LosAngeles&house=NewYork&house=null
   * 'house', ['LosAngeles', 'NewYork', null]
   * ];
   * </pre>
   */
  type QueryArray = any [] ;
}
// Generated from third_party/closure/goog/uri/utils.js
declare module 'goog:goog.uri.utils.QueryArray' {
  import QueryArray = ಠ_ಠ.clutz.goog.uri.utils.QueryArray;
  export default QueryArray;
}
// Generated from third_party/closure/goog/uri/utils.js
declare namespace ಠ_ಠ.clutz.goog.uri.utils {
  /**
   * Supported query parameter values by the parameter serializing utilities.
   *
   * If a value is null or undefined, the key-value pair is skipped, as an easy
   * way to omit parameters conditionally.  Non-array parameters are converted
   * to a string and URI encoded.  Array values are expanded into multiple
   * &key=value pairs, with each element stringized and URI-encoded.
   */
  type QueryValue = any ;
}
// Generated from third_party/closure/goog/uri/utils.js
declare module 'goog:goog.uri.utils.QueryValue' {
  import QueryValue = ಠ_ಠ.clutz.goog.uri.utils.QueryValue;
  export default QueryValue;
}
// Generated from third_party/closure/goog/uri/utils.js
declare namespace ಠ_ಠ.clutz.goog.uri.utils {
  /**
   * Standard supported query parameters.
   */
  /**
   * Standard supported query parameters.
   */
  enum StandardQueryParam {
    RANDOM = 'zx' ,
  }
}
// Generated from third_party/closure/goog/uri/utils.js
declare module 'goog:goog.uri.utils.StandardQueryParam' {
  import StandardQueryParam = ಠ_ಠ.clutz.goog.uri.utils.StandardQueryParam;
  export default StandardQueryParam;
}
