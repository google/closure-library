//!! generated by clutz.
// Generated from third_party/closure/goog/i18n/bidi.js
declare namespace ಠ_ಠ.clutz.goog.i18n.bidi {
  let FORCE_RTL : boolean ;
  /**
   * 'right' if locale is RTL, 'left' if not.
   */
  let I18N_LEFT : string ;
  /**
   * 'left' if locale is RTL, 'right' if not.
   */
  let I18N_RIGHT : string ;
  /**
   * Constant that defines whether or not the current locale is a RTL locale.
   * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
   * to check that {@link goog.LOCALE} is one of a few major RTL locales.
   *
   * <p>This is designed to be a maximally efficient compile-time constant. For
   * example, for the default goog.LOCALE, compiling
   * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
   * is this design consideration that limits the implementation to only
   * supporting a few major RTL locales, as opposed to the broader repertoire of
   * something like goog.i18n.bidi.isRtlLanguage.
   *
   * <p>Since this constant refers to the directionality of the locale, it is up
   * to the caller to determine if this constant should also be used for the
   * direction of the UI.
   *
   * {@see goog.LOCALE}
   */
  let IS_RTL : boolean ;
  /**
   * 'left' string constant.
   */
  let LEFT : string ;
  /**
   * 'right' string constant.
   */
  let RIGHT : string ;
  /**
   * Check the directionality of a piece of text, return true if the piece of
   * text should be laid out in RTL direction.
   * @param str The piece of text that need to be detected.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function detectRtlDirectionality (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Check if the exit directionality a piece of text is LTR, i.e. if the last
   * strongly-directional character in the string is LTR.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function endsWithLtr (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Check if the exit directionality a piece of text is RTL, i.e. if the last
   * strongly-directional character in the string is RTL.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function endsWithRtl (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Enforce the html snippet in RTL directionality regardless or overall context.
   * If the html piece was enclosed by tag, dir will be applied to existing
   * tag, otherwise a span tag will be added as wrapper. For this reason, if
   * html snippet starts with a tag, this tag must enclose the whole piece. If
   * the tag already has a dir specified, this new one will override existing
   * one in behavior (tested on FF and IE).
   * @param html The string that need to be processed.
   */
  function enforceLtrInHtml (html : string ) : string ;
  /**
   * Enforce LTR on both end of the given text piece using unicode BiDi formatting
   * characters LRE and PDF.
   * @param text The piece of text that need to be wrapped.
   */
  function enforceLtrInText (text : string ) : string ;
  /**
   * Enforce the html snippet in RTL directionality regardless of overall context.
   * If the html piece was enclosed by tag, dir will be applied to existing
   * tag, otherwise a span tag will be added as wrapper. For this reason, if
   * html snippet starts with a tag, this tag must enclose the whole piece. If
   * the tag already has a dir specified, this new one will override existing
   * one in behavior (tested on FF and IE).
   * @param html The string that need to be processed.
   */
  function enforceRtlInHtml (html : string ) : string ;
  /**
   * Enforce RTL on both end of the given text piece using unicode BiDi formatting
   * characters RLE and PDF.
   * @param text The piece of text that need to be wrapped.
   */
  function enforceRtlInText (text : string ) : string ;
  /**
   * Estimates the directionality of a string based on relative word counts.
   * If the number of RTL words is above a certain percentage of the total number
   * of strongly directional words, returns RTL.
   * Otherwise, if any words are strongly or weakly LTR, returns LTR.
   * Otherwise, returns UNKNOWN, which is used to mean "neutral".
   * Numbers are counted as weakly LTR.
   * @param str The string to be checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function estimateDirection (str : string , opt_isHtml ? : boolean ) : ಠ_ಠ.clutz.goog.i18n.bidi.Dir ;
  /**
   * Apply bracket guard using LRM and RLM. This is to address the problem of
   * messy bracket display frequently happens in RTL layout.
   * This function works for plain text, not for HTML. In HTML, the opening
   * bracket might be in a different context than the closing bracket (such as
   * an attribute value).
   * @param s The string that need to be processed.
   * @param opt_isRtlContext specifies default direction (usually direction of the UI).
   */
  function guardBracketInText (s : string , opt_isRtlContext ? : boolean ) : string ;
  /**
   * Test whether the given string has any LTR characters in it.
   * @param str The given string that need to be tested.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function hasAnyLtr (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Test whether the given string has any RTL characters in it.
   * @param str The given string that need to be tested.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function hasAnyRtl (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Test whether the given string has any RTL characters in it.
   * @param str The given string that need to be tested.
   * @deprecated Use hasAnyRtl.
   */
  function hasRtlChar (a : string ) : boolean ;
  /**
   * Check if the first character in the string is LTR or not.
   * @param str The given string that need to be tested.
   */
  function isLtrChar (str : string ) : boolean ;
  /**
   * Check if the exit directionality a piece of text is LTR, i.e. if the last
   * strongly-directional character in the string is LTR.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   * @deprecated Use endsWithLtr.
   */
  function isLtrExitText (a : string , b ? : boolean ) : boolean ;
  /**
   * Check whether the first strongly directional character (if any) is LTR.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   * @deprecated Use startsWithLtr.
   */
  function isLtrText (a : string , b ? : boolean ) : boolean ;
  /**
   * Check if the first character in the string is neutral or not.
   * @param str The given string that need to be tested.
   */
  function isNeutralChar (str : string ) : boolean ;
  /**
   * Check whether the input string either contains no strongly directional
   * characters or looks like a url.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function isNeutralText (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Check if the first character in the string is RTL or not.
   * @param str The given string that need to be tested.
   */
  function isRtlChar (str : string ) : boolean ;
  /**
   * Check if the exit directionality a piece of text is RTL, i.e. if the last
   * strongly-directional character in the string is RTL.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   * @deprecated Use endsWithRtl.
   */
  function isRtlExitText (a : string , b ? : boolean ) : boolean ;
  /**
   * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
   * - a language code explicitly specifying one of the right-to-left scripts,
   * e.g. "az-Arab", or<p>
   * - a language code specifying one of the languages normally written in a
   * right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
   * Latin or Cyrillic script (which are the usual LTR alternatives).<p>
   * The list of right-to-left scripts appears in the 100-199 range in
   * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
   * Hebrew are by far the most widely used. We also recognize Thaana, and N'Ko,
   * which also have significant modern usage. Adlam and Rohingya
   * scripts are now included since they can be expected to be used in the
   * future. The rest (Syriac, Samaritan, Mandaic, etc.) seem to have extremely
   * limited or no modern usage and are not recognized to save on code size. The
   * languages usually written in a right-to-left script are taken as those with
   * Suppress-Script: Hebr|Arab|Thaa|Nkoo|Adlm|Rohg in
   * http://www.iana.org/assignments/language-subtag-registry,
   * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
   * Other subtags of the language code, e.g. regions like EG (Egypt), are
   * ignored.
   * @param lang BCP 47 (a.k.a III) language code.
   */
  function isRtlLanguage (lang : string ) : boolean ;
  /**
   * Check whether the first strongly directional character (if any) is RTL.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   * @deprecated Use startsWithRtl.
   */
  function isRtlText (a : string , b ? : boolean ) : boolean ;
  /**
   * Swap location parameters and 'left'/'right' in CSS specification. The
   * processed string will be suited for RTL layout. Though this function can
   * cover most cases, there are always exceptions. It is suggested to put
   * those exceptions in separate group of CSS string.
   * @param cssStr CSS spefication string.
   */
  function mirrorCSS (cssStr : string ) : string ;
  /**
   * Replace the double and single quote directly after a Hebrew character with
   * GERESH and GERSHAYIM. In such case, most likely that's user intention.
   * @param str String that need to be processed.
   */
  function normalizeHebrewQuote (str : string ) : string ;
  /**
   * Sets text input element's directionality and text alignment based on a
   * given directionality. Does nothing if the given directionality is unknown or
   * neutral.
   * @param element Input field element to set directionality to.
   * @param dir Desired directionality, given in one of the following formats: 1. A goog.i18n.bidi.Dir constant. 2. A number (positive = LRT, negative = RTL, 0 = neutral). 3. A boolean (true = RTL, false = LTR). 4. A null for unknown directionality.
   */
  function setElementDirAndAlign (element : GlobalElement | null , dir : number | boolean | null ) : void ;
  /**
   * Sets element dir based on estimated directionality of the given text.
   */
  function setElementDirByTextDirectionality (element : GlobalElement , text : string ) : void ;
  /**
   * Check whether the first strongly directional character (if any) is LTR.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function startsWithLtr (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Check whether the first strongly directional character (if any) is RTL.
   * @param str String being checked.
   * @param opt_isHtml Whether str is HTML / HTML-escaped. Default: false.
   */
  function startsWithRtl (str : string , opt_isHtml ? : boolean ) : boolean ;
  /**
   * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
   * constant. Useful for interaction with different standards of directionality
   * representation.
   * @param givenDir Directionality given in one of the following formats: 1. A goog.i18n.bidi.Dir constant. 2. A number (positive = LTR, negative = RTL, 0 = neutral). 3. A boolean (true = RTL, false = LTR). 4. A null for unknown directionality.
   * @param opt_noNeutral Whether a givenDir of zero or goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in order to preserve legacy behavior.
   */
  function toDir (givenDir : number | boolean | null , opt_noNeutral ? : boolean ) : ಠ_ಠ.clutz.goog.i18n.bidi.Dir | null ;
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare module 'goog:goog.i18n.bidi' {
  import bidi = ಠ_ಠ.clutz.goog.i18n.bidi;
  export = bidi;
  const __clutz_actual_path: 'google3/third_party/closure/goog/i18n/bidi';
}
declare module 'google3/third_party/closure/goog/i18n/bidi' {
  import bidi = ಠ_ಠ.clutz.goog.i18n.bidi;
  export = bidi;
  const __clutz_actual_namespace: 'goog.i18n.bidi';
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare namespace ಠ_ಠ.clutz.goog.i18n.bidi {
  /**
   * Directionality enum.
   */
  /**
   * Directionality enum.
   */
  enum Dir {
    LTR = 1.0 ,
    NEUTRAL = 0.0 ,
    RTL = -1.0 ,
  }
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare module 'goog:goog.i18n.bidi.Dir' {
  import Dir = ಠ_ಠ.clutz.goog.i18n.bidi.Dir;
  export default Dir;
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare namespace ಠ_ಠ.clutz.goog.i18n.bidi {
  /**
   * Strings that have an (optional) known direction.
   *
   * Implementations of this interface are string-like objects that carry an
   * attached direction, if known.
   */
  interface DirectionalString {
    /**
     * Retrieves this object's known direction (if any).
     */
    getDirection ( ) : ಠ_ಠ.clutz.goog.i18n.bidi.Dir | null ;
    /**
     * Interface marker of the DirectionalString interface.
     *
     * This property can be used to determine at runtime whether or not an object
     * implements this interface.  All implementations of this interface set this
     * property to `true`.
     */
    implementsGoogI18nBidiDirectionalString : boolean ;
  }
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare module 'goog:goog.i18n.bidi.DirectionalString' {
  import DirectionalString = ಠ_ಠ.clutz.goog.i18n.bidi.DirectionalString;
  export default DirectionalString;
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare namespace ಠ_ಠ.clutz.goog.i18n.bidi {
  /**
   * Unicode formatting characters and directionality string constants.
   */
  /**
   * Unicode formatting characters and directionality string constants.
   */
  enum Format {
    LRE = '\u202A' ,
    LRM = '\u200E' ,
    PDF = '\u202C' ,
    RLE = '\u202B' ,
    RLM = '\u200F' ,
  }
}
// Generated from third_party/closure/goog/i18n/bidi.js
declare module 'goog:goog.i18n.bidi.Format' {
  import Format = ಠ_ಠ.clutz.goog.i18n.bidi.Format;
  export default Format;
}
